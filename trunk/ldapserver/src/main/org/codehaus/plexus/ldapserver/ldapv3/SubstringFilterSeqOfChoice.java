package org.codehaus.plexus.ldapserver.ldapv3;

//-----------------------------------------------------------------------------
//   NOTE: this is a machine generated file - editing not recommended
//
//   File: ./src/org/codehaus/ldapv3/SubstringFilterSeqOfChoice.java
//
//   Java class for ASN.1 definition SubstringFilterSeqOfChoice as defined in
//   module LDAPv3.
//   This file was generated by Snacc for Java at Fri Jul  2 18:01:43 1999
//   Snacc for Java - Andreas Schade (SAN/ZRL)
//-----------------------------------------------------------------------------

// Import PrintStream class for print methods

import com.ibm.asn1.*;
import com.ibm.util.*;

import java.io.PrintStream;

/** This class represents the ASN.1 CHOICE type <tt>SubstringFilterSeqOfChoice</tt>.
 * Choice classes contain a selector variable <tt>choiceId</tt>
 * of type <tt>int</tt> indicating which of the choice elements
 * is represented. For each choice element there is a constant
 * integer value defined to which <tt>choiceId</tt> can be set.
 * <P>The ASN.1 choice elements are represented by public
 * member varaibles of the corresponding Java type.
 * @author Snacc for Java
 * @version Fri Jul  2 18:01:43 1999

 */

public class SubstringFilterSeqOfChoice implements LDAPv3
{

    static public final int INITIAL_CID = 0;
    static public final int ANY_CID = 1;
    static public final int FINAL1_CID = 2;

    int tag_list[] = {INITIAL_CID, ANY_CID, FINAL1_CID};

    public int choiceId;
    public byte[] initial = null;
    public byte[] any = null;
    public byte[] final1 = null;

    /** default constructor */
    public SubstringFilterSeqOfChoice()
    {
    }

    /** copy constructor */
    public SubstringFilterSeqOfChoice( SubstringFilterSeqOfChoice arg )
    {
        choiceId = arg.choiceId;

        switch ( choiceId )
        {
            case INITIAL_CID:
                initial = new byte[arg.initial.length];
                System.arraycopy( arg.initial, 0, initial, 0, arg.initial.length );
                break;
            case ANY_CID:
                any = new byte[arg.any.length];
                System.arraycopy( arg.any, 0, any, 0, arg.any.length );
                break;
            case FINAL1_CID:
                final1 = new byte[arg.final1.length];
                System.arraycopy( arg.final1, 0, final1, 0, arg.final1.length );
                break;
        }
    }

    /** decoding method.
     * @param dec
     *        decoder object derived from com.ibm.asn1.ASN1Decoder
     * @exception com.ibm.asn1.ASN1Exception
     *            decoding error
     */
    public void decode( ASN1Decoder dec ) throws ASN1Exception
    {
        int tag = dec.decodeChoice( tag_list );
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 0 ) )
        {
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 0 ) );
            initial = dec.decodeOctetString();
            choiceId = INITIAL_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 1 ) )
        {
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 1 ) );
            any = dec.decodeOctetString();
            choiceId = ANY_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 2 ) )
        {
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 2 ) );
            final1 = dec.decodeOctetString();
            choiceId = FINAL1_CID;
        }
    }

    /** encoding method.
     * @param enc
     *        encoder object derived from com.ibm.asn1.ASN1Encoder
     * @exception com.ibm.asn1.ASN1Exception
     *            encoding error
     */
    public void encode( ASN1Encoder enc ) throws ASN1Exception
    {
        enc.encodeChoice( choiceId, tag_list );
        switch ( choiceId )
        {
            case INITIAL_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 0 ) );
                enc.encodeOctetString( initial );
                break;
            case ANY_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 1 ) );
                enc.encodeOctetString( any );
                break;
            case FINAL1_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 2 ) );
                enc.encodeOctetString( final1 );
                break;
        }
    }

    /** default print method (variable indentation)
     * @param os
     *        PrintStream representing the print destination (file, etc)
     */
    public void print( PrintStream os )
    {
        print( os, 0 );
    }

    /** print method (variable indentation)
     * @param os
     *        PrintStream representing the print destination (file, etc)
     * @param indent
     *        number of blanks that preceed each output line.
     */
    public void print( PrintStream os, int indent )
    {
        os.println( "{ -- CHOICE --" );
        switch ( choiceId )
        {
            case INITIAL_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "initial = " );
                try
                {
                    ( new HexOutputStream( os ) ).write( initial );
                }
                catch ( java.io.IOException ex )
                {
                    os.print( "( unprintable OCTET STRING value )" );
                }
                break;
            case ANY_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "any = " );
                try
                {
                    ( new HexOutputStream( os ) ).write( any );
                }
                catch ( java.io.IOException ex )
                {
                    os.print( "( unprintable OCTET STRING value )" );
                }
                break;
            case FINAL1_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "final = " );
                try
                {
                    ( new HexOutputStream( os ) ).write( final1 );
                }
                catch ( java.io.IOException ex )
                {
                    os.print( "( unprintable OCTET STRING value )" );
                }
                break;
        }
        for ( int ii = 0; ii < indent; ii++ ) os.print( ' ' );
        os.print( "}" );
    }
}
