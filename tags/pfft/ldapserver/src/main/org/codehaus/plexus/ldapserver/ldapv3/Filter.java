package org.codehaus.plexus.ldapserver.ldapv3;

//-----------------------------------------------------------------------------
//   NOTE: this is a machine generated file - editing not recommended
//
//   File: ./src/org/codehaus/ldapv3/Filter.java
//
//   Java class for ASN.1 definition Filter as defined in
//   module LDAPv3.
//   This file was generated by Snacc for Java at Fri Jul  2 18:01:43 1999
//   Snacc for Java - Andreas Schade (SAN/ZRL)
//-----------------------------------------------------------------------------

// Import PrintStream class for print methods

import com.ibm.asn1.*;
import com.ibm.util.*;

import java.io.PrintStream;

/** This class represents the ASN.1 CHOICE type <tt>Filter</tt>.
 * Choice classes contain a selector variable <tt>choiceId</tt>
 * of type <tt>int</tt> indicating which of the choice elements
 * is represented. For each choice element there is a constant
 * integer value defined to which <tt>choiceId</tt> can be set.
 * <P>The ASN.1 choice elements are represented by public
 * member varaibles of the corresponding Java type.
 * @author Snacc for Java
 * @version Fri Jul  2 18:01:43 1999

 */

public class Filter implements LDAPv3
{

    static public final int AND_CID = 0;
    static public final int OR_CID = 1;
    static public final int NOT_CID = 2;
    static public final int EQUALITYMATCH_CID = 3;
    static public final int SUBSTRINGS_CID = 4;
    static public final int GREATEROREQUAL_CID = 5;
    static public final int LESSOREQUAL_CID = 6;
    static public final int PRESENT_CID = 7;
    static public final int APPROXMATCH_CID = 8;
    static public final int EXTENSIBLEMATCH_CID = 9;

    int tag_list[] = {AND_CID, OR_CID, NOT_CID, EQUALITYMATCH_CID, SUBSTRINGS_CID, GREATEROREQUAL_CID, LESSOREQUAL_CID, PRESENT_CID, APPROXMATCH_CID, EXTENSIBLEMATCH_CID};

    public int choiceId;
    public FilterSetOf and = null;
    public FilterSetOf1 or = null;
    public Filter not = null;
    public AttributeValueAssertion equalityMatch = null;
    public SubstringFilter substrings = null;
    public AttributeValueAssertion greaterOrEqual = null;
    public AttributeValueAssertion lessOrEqual = null;
    public byte[] present = null;
    public AttributeValueAssertion approxMatch = null;
    public MatchingRuleAssertion extensibleMatch = null;

    /** default constructor */
    public Filter()
    {
    }

    /** copy constructor */
    public Filter( Filter arg )
    {
        choiceId = arg.choiceId;

        switch ( choiceId )
        {
            case AND_CID:
                and = new FilterSetOf( arg.and );
                break;
            case OR_CID:
                or = new FilterSetOf1( arg.or );
                break;
            case NOT_CID:
                not = new Filter( arg.not );
                break;
            case EQUALITYMATCH_CID:
                equalityMatch = new AttributeValueAssertion( arg.equalityMatch );
                break;
            case SUBSTRINGS_CID:
                substrings = new SubstringFilter( arg.substrings );
                break;
            case GREATEROREQUAL_CID:
                greaterOrEqual = new AttributeValueAssertion( arg.greaterOrEqual );
                break;
            case LESSOREQUAL_CID:
                lessOrEqual = new AttributeValueAssertion( arg.lessOrEqual );
                break;
            case PRESENT_CID:
                present = new byte[arg.present.length];
                System.arraycopy( arg.present, 0, present, 0, arg.present.length );
                break;
            case APPROXMATCH_CID:
                approxMatch = new AttributeValueAssertion( arg.approxMatch );
                break;
            case EXTENSIBLEMATCH_CID:
                extensibleMatch = new MatchingRuleAssertion( arg.extensibleMatch );
                break;
        }
    }

    /** decoding method.
     * @param dec
     *        decoder object derived from com.ibm.asn1.ASN1Decoder
     * @exception com.ibm.asn1.ASN1Exception
     *            decoding error
     */
    public void decode( ASN1Decoder dec ) throws ASN1Exception
    {
        int tag = dec.decodeChoice( tag_list );
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 0 ) )
        {
            and = new FilterSetOf();
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 0 ) );
            and.decode( dec );
            choiceId = AND_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 1 ) )
        {
            or = new FilterSetOf1();
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 1 ) );
            or.decode( dec );
            choiceId = OR_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 2 ) )
        {
            not = new Filter();
            int ex_id_not = dec.decodeExplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 2 ) );
            not.decode( dec );
            dec.endOf( ex_id_not );
            choiceId = NOT_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 3 ) )
        {
            equalityMatch = new AttributeValueAssertion();
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 3 ) );
            equalityMatch.decode( dec );
            choiceId = EQUALITYMATCH_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 4 ) )
        {
            substrings = new SubstringFilter();
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 4 ) );
            substrings.decode( dec );
            choiceId = SUBSTRINGS_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 5 ) )
        {
            greaterOrEqual = new AttributeValueAssertion();
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 5 ) );
            greaterOrEqual.decode( dec );
            choiceId = GREATEROREQUAL_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 6 ) )
        {
            lessOrEqual = new AttributeValueAssertion();
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 6 ) );
            lessOrEqual.decode( dec );
            choiceId = LESSOREQUAL_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 7 ) )
        {
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 7 ) );
            present = dec.decodeOctetString();
            choiceId = PRESENT_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 8 ) )
        {
            approxMatch = new AttributeValueAssertion();
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 8 ) );
            approxMatch.decode( dec );
            choiceId = APPROXMATCH_CID;
        }
        if ( tag == dec.makeTag( dec.CONTEXT_TAG_CLASS, 9 ) )
        {
            extensibleMatch = new MatchingRuleAssertion();
            dec.nextIsImplicit( dec.makeTag( dec.CONTEXT_TAG_CLASS, 9 ) );
            extensibleMatch.decode( dec );
            choiceId = EXTENSIBLEMATCH_CID;
        }
    }

    /** encoding method.
     * @param enc
     *        encoder object derived from com.ibm.asn1.ASN1Encoder
     * @exception com.ibm.asn1.ASN1Exception
     *            encoding error
     */
    public void encode( ASN1Encoder enc ) throws ASN1Exception
    {
        enc.encodeChoice( choiceId, tag_list );
        switch ( choiceId )
        {
            case AND_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 0 ) );
                and.encode( enc );
                break;
            case OR_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 1 ) );
                or.encode( enc );
                break;
            case NOT_CID:
                int ex_id_not = enc.encodeExplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 2 ) );
                not.encode( enc );
                enc.endOf( ex_id_not );
                break;
            case EQUALITYMATCH_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 3 ) );
                equalityMatch.encode( enc );
                break;
            case SUBSTRINGS_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 4 ) );
                substrings.encode( enc );
                break;
            case GREATEROREQUAL_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 5 ) );
                greaterOrEqual.encode( enc );
                break;
            case LESSOREQUAL_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 6 ) );
                lessOrEqual.encode( enc );
                break;
            case PRESENT_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 7 ) );
                enc.encodeOctetString( present );
                break;
            case APPROXMATCH_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 8 ) );
                approxMatch.encode( enc );
                break;
            case EXTENSIBLEMATCH_CID:
                enc.nextIsImplicit( enc.makeTag( enc.CONTEXT_TAG_CLASS, 9 ) );
                extensibleMatch.encode( enc );
                break;
        }
    }

    /** default print method (variable indentation)
     * @param os
     *        PrintStream representing the print destination (file, etc)
     */
    public void print( PrintStream os )
    {
        print( os, 0 );
    }

    /** print method (variable indentation)
     * @param os
     *        PrintStream representing the print destination (file, etc)
     * @param indent
     *        number of blanks that preceed each output line.
     */
    public void print( PrintStream os, int indent )
    {
        os.println( "{ -- CHOICE --" );
        switch ( choiceId )
        {
            case AND_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "and = " );
                and.print( os, indent + 2 );
                break;
            case OR_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "or = " );
                or.print( os, indent + 2 );
                break;
            case NOT_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "not = " );
                not.print( os, indent + 2 );
                break;
            case EQUALITYMATCH_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "equalityMatch = " );
                equalityMatch.print( os, indent + 2 );
                break;
            case SUBSTRINGS_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "substrings = " );
                substrings.print( os, indent + 2 );
                break;
            case GREATEROREQUAL_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "greaterOrEqual = " );
                greaterOrEqual.print( os, indent + 2 );
                break;
            case LESSOREQUAL_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "lessOrEqual = " );
                lessOrEqual.print( os, indent + 2 );
                break;
            case PRESENT_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "present = " );
                try
                {
                    ( new HexOutputStream( os ) ).write( present );
                }
                catch ( java.io.IOException ex )
                {
                    os.print( "( unprintable OCTET STRING value )" );
                }
                break;
            case APPROXMATCH_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "approxMatch = " );
                approxMatch.print( os, indent + 2 );
                break;
            case EXTENSIBLEMATCH_CID:
                for ( int ii = 0; ii < indent + 2; ii++ ) os.print( ' ' );
                os.print( "extensibleMatch = " );
                extensibleMatch.print( os, indent + 2 );
                break;
        }
        for ( int ii = 0; ii < indent; ii++ ) os.print( ' ' );
        os.print( "}" );
    }
}
